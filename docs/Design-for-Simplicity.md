#   Design for Simplicity

The portable Parser Expression Grammar system pPEG aims to be as simple as possible. To do this several features that are provided by other grammar parser systems are not supported in pPEG. It is a bit of a surprise that the lack of these features does not result in any significant loss of either grammar expressive power or performance.

The benefits of simplicity far outweigh any loss of function. If the lack of functionality ever becomes an issue then pPEG has an extension feature that can be used as an escape hatch to do whatever is required. Of course this escape hatch could be abused, but limited extensions do not cause any problems, and most grammars found in practice do not require any extensions.

Now for a list of things that pPEG does not do:

##	No Ambiguity

A pPEG is a form of PEG with committed choices that can only define unambiguous grammars.  Most computer languages, protocols, and data structure specifications, are unambiguous by design, so this is a positive advantage and not a limitation.  

Traditional grammar specifications use a Context Free Grammar or CFG, and these grammars can be ambiguous.   That means the grammar can derive the same string in more than one way. There is no good examples of a language with a CFG  grammar that can not be expressed with a PEG grammar, but there are examples of PEG grammars that can not be expressed as a CFG.

There are however some applications, such as natural language processing, that may need ambiguity. For these applications a PEG is not suitable. There are good grammar parser generators such as [GLL parsing] that extend the advantage of a PEG style recursive descent parsing to include ambiguous grammars.

[GLL parsing]: https://www.sciencedirect.com/science/article/pii/S1571066110001209

##	No Lexical Scanner

Traditional parsers employ a lexical scanner as a pre-processor to generate a token stream for the parser to process.   This may simplify program implementation and help performance, but it complicates the user’s model because two separate grammars are required, one for the lexical tokens and another for the main grammar. 

PEG grammar rules integrate the lexical matching rules into a single grammar. This integration also provides some extra expressive power in that lexical rules can be applied more selectively. This flexibility is difficult to provide with a separate lexical scanner.


##	No Semantic Actions

Some parsers allow grammar rules to be extended with semantic actions that can transform the results generated by grammar rules. This is a powerful feature, but it conflates the grammar rules with processing instructions using a general purpose programming language. 

To keep the grammar clean and portable the pPEG grammar does not support semantic actions. The parser builds a parse tree from the grammar before any semantic actions are applied. The semantic actions are implemented as parse tree transformations. 

However, in rare cases a semantic action may be essential to the operation of the parser.  If the parser really requires semantic actions then either the grammar is poorly designed, or the syntax is so complicated that it can not be expressed with PEG (or CFG) rules. This can happen occasionally and the pPEG extension feature can be used to deal with these gnarly grammars [see pPEG context sensitive grammars].

[see pPEG context sensitive grammars]: https://github.com/pcanz/pPEG/blob/master/docs/context-sensitive-grammars.md

Semantic actions may also be used to improve performance, and if required pPEG extensions can be used for that as well. 

In fact pPEG extensions can do anything that a semantic action can do.  It boils down to the philosophy.  Semantic actions are seen as an integral part of the grammar. In contrast, grammar extensions in pPEG are thought of as exceptions that are only employed when there is no other option.

Most semantic actions are much better implemented as parse tree transform functions that are applied after a parse tree has been generated.


##	No Packrat Memos

A PEG grammar can achieve linear O(n) performance if it keeps memos for rule results to avoid re-parsing the same input more than once. Unfortunately this can result in explosive memory usage, but fortunately packrat memos are rarely required in practice. 

PEG grammar rules can almost always be rewritten to avoid the need for packrat memos. As a simple example:

	s = x y / x z

This rule requires the `x` to be parsed twice to match the second alternative, but it can be rewritten as:

	s = x (y / z)

Another example, a traditional CFG rule for a list might be expressed as:

	list = item “ , “ list | item

But idiomatic PEG would instead write it as:

	list = item (“ , “ item)*

This generates a flat list (no recursion) without the need to backtrack and re-parse the same `item`. Idiomatic PEG grammars employ rules that naturally avoid the need for memos. 

In theory packrat memos are needed to avoid exponential performance.  But in practice this is not an issue.  If it ever becomes necessary a pPEG extension can be used to provide memos for selected results.


## Simpler Parse Trees

The pPEG grammar rule names label the parse tree nodes that they generate. It is natural to employ rule names that denote a semantic meaning so that the parse tree can be read as a semantic markup of the input text.

Anonymous matches (such as literal quotes) are eliminated and do not appear in the parse tree. The parser will also eliminate redundant nodes to simplify the parse tree. But the pPEG rule name conventions allow the grammar designer explicit control to include or exclude the generation of individul grammar rule results.

The pPEG grammar rules are syntax pattern recognizers. A parser can execute the grammar rules directly as instructions to match against an input string and generate a parse tree. The focus of the grammar design is on pattern matching of the input string to generate an SST (Semantic Syntax Tree), rather than on the derivation of a traditional AST (Abstract Syntax Tree). An SST is a type of AST that is simpler than a full blown CST (Concrete Parse Tree). 

For example, for this date grammar:

    date  = year ‘-‘ month ‘-‘ day
    year  = [0-9]*4 
    month = [0-9]*2 
    day   = [0-9]*2

The parse tree from parsing the input “2022-03-04” can be diplayed as:

	date
	├─year "2022"
	├─month "03"
	└─day "04"

Or it may be diplayed as an XML markup:

	<date><year>2022</year>-<month>03</month>-<day>04</day></date>

The semantic markup format shows the complete input string but it may be too verbose.

The same parse tree result may be shown as a Lisp s-expression:

	(date (year “2022”) (month “03”) (day “04”))

The s-expression format can be interpreted as a semantic `date` function with three arguments.

Or the parse tree can be seen as a JSON data structure:

	[“date”, [[“year”, “2022”], [“month”, “03”], [“day”, “04"]]]

An application can define a function for the `date` tag to translate the date text fields into a programming language data type.

There are different ways to display the parse tree in a human readable format. However, the underlying implementation of the parse tree is expected to contain index pointers into the input string.

For example:

	{ tag: “date”, start: 0, end: 10,  args: [
		{ tag: “year”, start: 0, end: 4, args: [] },
		{ tag: “month”, start: 5, end: 7, args: [] },
		{ tag: “day”, start: 8, end: 10, args: [] }
    ]}
	
This allows applications to relate parse tree nodes back to the full input text that they were derived from. This is useful for text transformation applications and for error reporting.

The internal parse tree data structure can be implemented in whatevert way suits the host programming language.  An s-expression or JSON format can provides a portable representation that is independent of the programming language and implementation details.

The JSON format with index information:

	[“date”, 0, 10, [“year”, “2022”], [“month”, “03”], [“day”, “04"]]

In summary, a pPEG parser generates a SST, rather than an AST (or CST). A SST is a simplified parse tree that applies the grammar rule names as semantic tags. This creates a semantic markup of the input text that can be used to represent programming language data types.


##	No Left Recursion

Left recursion is quite common in traditional grammar specifications, but this is not possible in a standard PEG specification, although there are algorithms that can extend a PEG with left recursion.

Left recursion can always be removed by rewriting the grammar, for example:

	exp = exp op term / term

In pPEG this would be written as:

	exp = term (op term)*

Some people find left recursion very expressive and believe that the PEG version is a poor substitute.  This opinion seems to boil down to the fact that the left recursion shows that the expression is left associative.

In a pPEG grammar the rule name is a semantic tag to denote the meaning of the matched text, and that includes whether the operator is left or right associative, or neither.

A pPEG parser generates a parse tree in the form of a Semantic Markup Tree, or SMT. The rule result is a flat list of terms with the rule name as a prefix in the form of a function expression:

	add = term (‘+’ term)*   =>  (add term term term …)  =>  (+ 1 2 3)

The nodes in the parse tree are in the form of a function with multiple arguments, rather than the traditional binary operator tree for infix operators.

The functional form is very versatile and the semantic tag (rule name) can be implemented with a function that evaluates the form in many different ways. It may be left (or right) associative and reduce the list with a reduce or fold function, but it can evaluate the from in any way required.

For example:

    lt = a < b < c  => (lt a b c) => (< 1 2 3) => 1<2 & 2<3 & 3<4 => true

Programming languages that support this kind of expression include Python, Julia, Racket, and others.

Another example:

	if = 'if' p x y   =>  (if p x y)  => x if p, else y

The `if` function evaluates either `x` or `y` but not both.

A left recursive grammar rule works well for left associative binary infix operators, but the more general functional form is uniform and flexible.  In a pPEG left associativity is determined by the semantics that the rule name denotes, rather than the form of the grammar rule.  

However, a pPEG grammar needs a rule for every operator (or maybe a group of operators) since the operator defines the semantics. But if the grammar has a very large number of operators then the number of grammar rules can become excessive.  In this case the solution is to simplify the grammar to match a sequence of many different operators and operands, and then use a Pratt algorithm to transform the list:

	exp = term (op term)*   =>  (exp term op term op term …)

     =>  (exp 1 + 2 * 3)  =>  (+ 1 (* 2 3))

For the details [see pPEG operator expressions].

[see pPEG operator expressions]: https://github.com/pcanz/pPEG/blob/master/docs/operator-expressions.md


##	No Regex

It is very tempting to extend PEG rules with regex matching. This is attractive because of the power and raw speed of a regex matcher.  But this introduces significant complications, so for simplicity pPEG does not support regex elements directly, although a custom extension can always be used to apply a regex if that is every required.

Using a regex introduces conceptual problems because a regex supports nondeterministic backtracking while PEG expressions do not.  For example, a regex could match a file name at the end of a file path like this:

	path = .*/(.+)  where a . dot represents any char

This matches everything to the end, and then tries to match a `/` slash character. This requires the parser to back-track from the end, back to the first `/` slash.

The equivalent expression as a PEG does not work: 

    path = any* ‘/‘ file     # won't work
    file = any+
    any  = ~[]

Matching any character any number of times will match everything, leaving nothing else to match, so it will than fail to match a `/` slash. This is because a PEG makes a committed choice and can not backtrack in the way a regex can.

Instead of overshooting and backtracking a PEG can use unlimited look-ahead before making a committed choice.

In a pPEG it could be expressed like this:

    path = (~'/'* ‘/‘)* file
    file = any+

This matches segments with any characters other than a `/` slash that end with a `/`. The path name before the file name is any number of these segments. The final remainder is the file name.

The mental model for matching with a PEG grammar is different from the mental model for matching with a Regex.

A regex adds a lot more complexity because of the cryptic syntax and the many different extensions and variations offered by different regex implementations.

A regex can be very fast, but there is no fundamental reason why a pPEG parser can not be equally competitive.


##	Summary

The pPEG grammar has been kept as simple as possible by not supporting many features provided by other grammar parser systems. But there is very little down-side to this simplicity, there is no significant loss of grammar expressive power or parser performance.
 

